
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>implementations.convergence_controller_classes.adaptivity &#8212; pySDC 5.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/classic.css" />
    
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">pySDC 5.0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">implementations.convergence_controller_classes.adaptivity</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for implementations.convergence_controller_classes.adaptivity</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pySDC.core.ConvergenceController</span> <span class="kn">import</span> <span class="n">ConvergenceController</span>
<span class="kn">from</span> <span class="nn">pySDC.implementations.convergence_controller_classes.estimate_embedded_error</span> <span class="kn">import</span> <span class="n">EstimateEmbeddedErrorNonMPI</span>
<span class="kn">from</span> <span class="nn">pySDC.implementations.convergence_controller_classes.step_size_limiter</span> <span class="kn">import</span> <span class="n">StepSizeLimiter</span>
<span class="kn">from</span> <span class="nn">pySDC.implementations.convergence_controller_classes.basic_restarting_nonMPI</span> <span class="kn">import</span> <span class="n">BasicRestartingNonMPI</span>
<span class="kn">from</span> <span class="nn">pySDC.implementations.controller_classes.controller_nonMPI</span> <span class="kn">import</span> <span class="n">controller_nonMPI</span>


<div class="viewcode-block" id="AdaptivityBase"><a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.html#implementations.convergence_controller_classes.adaptivity.AdaptivityBase">[docs]</a><span class="k">class</span> <span class="nc">AdaptivityBase</span><span class="p">(</span><span class="n">ConvergenceController</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract base class for convergence controllers that implement adaptivity based on arbitrary local error estimates</span>
<span class="sd">    and update rules.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="AdaptivityBase.setup"><a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.html#implementations.convergence_controller_classes.adaptivity.AdaptivityBase.setup">[docs]</a>    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">description</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define default parameters here.</span>

<span class="sd">        Default parameters are:</span>
<span class="sd">         - control_order (int): The order relative to other convergence controllers</span>
<span class="sd">         - beta (float): The safety factor</span>

<span class="sd">        Args:</span>
<span class="sd">            controller (pySDC.Controller): The controller</span>
<span class="sd">            params (dict): The params passed for this specific convergence controller</span>
<span class="sd">            description (dict): The description object used to instantiate the controller</span>

<span class="sd">        Returns:</span>
<span class="sd">            (dict): The updated params dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;control_order&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">50</span><span class="p">,</span>
            <span class="s1">&#39;beta&#39;</span><span class="p">:</span> <span class="mf">0.9</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="p">{</span><span class="o">**</span><span class="n">defaults</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">}</span></div>

<div class="viewcode-block" id="AdaptivityBase.dependencies"><a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.html#implementations.convergence_controller_classes.adaptivity.AdaptivityBase.dependencies">[docs]</a>    <span class="k">def</span> <span class="nf">dependencies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="n">description</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load step size limiters here, if they are desired.</span>

<span class="sd">        Args:</span>
<span class="sd">            controller (pySDC.Controller): The controller</span>
<span class="sd">            description (dict): The description object used to instantiate the controller</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;dt_min&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">or</span> <span class="s1">&#39;dt_max&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">step_limiter_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="n">step_limiter_params</span><span class="p">[</span><span class="s1">&#39;dt_min&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dt_min&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">step_limiter_params</span><span class="p">[</span><span class="s1">&#39;dt_max&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dt_max&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
            <span class="n">controller</span><span class="o">.</span><span class="n">add_convergence_controller</span><span class="p">(</span><span class="n">StepSizeLimiter</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">step_limiter_params</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="AdaptivityBase.get_new_step_size"><a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.html#implementations.convergence_controller_classes.adaptivity.AdaptivityBase.get_new_step_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_new_step_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine a step size for the next step from an estimate of the local error of the current step.</span>

<span class="sd">        Args:</span>
<span class="sd">            controller (pySDC.Controller): The controller</span>
<span class="sd">            S (pySDC.Step): The current step</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Please implement a rule for updating the step size!&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="AdaptivityBase.compute_optimal_step_size"><a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.html#implementations.convergence_controller_classes.adaptivity.AdaptivityBase.compute_optimal_step_size">[docs]</a>    <span class="k">def</span> <span class="nf">compute_optimal_step_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">e_tol</span><span class="p">,</span> <span class="n">e_est</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the optimal step size for the current step based on the order of the scheme.</span>
<span class="sd">        This function can be called from `get_new_step_size` for various implementations of adaptivity, but notably not</span>
<span class="sd">        all! We require to know the order of the error estimate and if we do adaptivity based on the residual, for</span>
<span class="sd">        instance, we do not know that and we can&#39;t use this function.</span>

<span class="sd">        Args:</span>
<span class="sd">            beta (float): Safety factor</span>
<span class="sd">            dt (float): Current step size</span>
<span class="sd">            e_tol (float): The desired tolerance</span>
<span class="sd">            e_est (float): The estimated local error</span>
<span class="sd">            order (int): The order of the local error estimate</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: The optimal step size</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="p">(</span><span class="n">e_tol</span> <span class="o">/</span> <span class="n">e_est</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">order</span><span class="p">)</span></div>

<div class="viewcode-block" id="AdaptivityBase.get_local_error_estimate"><a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.html#implementations.convergence_controller_classes.adaptivity.AdaptivityBase.get_local_error_estimate">[docs]</a>    <span class="k">def</span> <span class="nf">get_local_error_estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the local error estimate for updating the step size.</span>
<span class="sd">        It does not have to be an error estimate, but could be the residual or something else.</span>

<span class="sd">        Args:</span>
<span class="sd">            controller (pySDC.Controller): The controller</span>
<span class="sd">            S (pySDC.Step): The current step</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: The error estimate</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Please implement a way to get the local error&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="AdaptivityBase.determine_restart"><a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.html#implementations.convergence_controller_classes.adaptivity.AdaptivityBase.determine_restart">[docs]</a>    <span class="k">def</span> <span class="nf">determine_restart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the step wants to be restarted by comparing the estimate of the local error to a preset tolerance</span>

<span class="sd">        Args:</span>
<span class="sd">            controller (pySDC.Controller): The controller</span>
<span class="sd">            S (pySDC.Step): The current step</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">S</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">iter</span> <span class="o">==</span> <span class="n">S</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">maxiter</span><span class="p">:</span>
            <span class="n">e_est</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_local_error_estimate</span><span class="p">(</span><span class="n">controller</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">e_est</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">e_tol</span><span class="p">:</span>
                <span class="n">S</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">restart</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Restarting: e=</span><span class="si">{</span><span class="n">e_est</span><span class="si">:</span><span class="s1">.2e</span><span class="si">}</span><span class="s1"> &gt;= e_tol=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">e_tol</span><span class="si">:</span><span class="s1">.2e</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span></div></div>


<div class="viewcode-block" id="Adaptivity"><a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.html#implementations.convergence_controller_classes.adaptivity.Adaptivity">[docs]</a><span class="k">class</span> <span class="nc">Adaptivity</span><span class="p">(</span><span class="n">AdaptivityBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to compute time step size adaptively based on embedded error estimate.</span>

<span class="sd">    We have a version working in non-MPI pipelined SDC, but Adaptivity requires you to know the order of the scheme,</span>
<span class="sd">    which you can also know for block-Jacobi, but it works differently and it is only implemented for block</span>
<span class="sd">    Gauss-Seidel so far.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Adaptivity.dependencies"><a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.html#implementations.convergence_controller_classes.adaptivity.Adaptivity.dependencies">[docs]</a>    <span class="k">def</span> <span class="nf">dependencies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="n">description</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the embedded error estimator.</span>

<span class="sd">        Args:</span>
<span class="sd">            controller (pySDC.Controller): The controller</span>
<span class="sd">            description (dict): The description object used to instantiate the controller</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Adaptivity</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">dependencies</span><span class="p">(</span><span class="n">controller</span><span class="p">,</span> <span class="n">description</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">controller</span><span class="p">)</span> <span class="o">==</span> <span class="n">controller_nonMPI</span><span class="p">:</span>
            <span class="n">controller</span><span class="o">.</span><span class="n">add_convergence_controller</span><span class="p">(</span><span class="n">EstimateEmbeddedErrorNonMPI</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;I only have an implementation of the embedded error for non MPI versions&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Adaptivity.check_parameters"><a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.html#implementations.convergence_controller_classes.adaptivity.Adaptivity.check_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">check_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">description</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether parameters are compatible with whatever assumptions went into the step size functions etc.</span>
<span class="sd">        For adaptivity, we need to know the order of the scheme.</span>

<span class="sd">        Args:</span>
<span class="sd">            controller (pySDC.Controller): The controller</span>
<span class="sd">            params (dict): The params passed for this specific convergence controller</span>
<span class="sd">            description (dict): The description object used to instantiate the controller</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: Whether the parameters are compatible</span>
<span class="sd">            str: The error message</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">description</span><span class="p">[</span><span class="s1">&#39;step_params&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;restol&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="kc">False</span><span class="p">,</span>
                <span class="s1">&#39;Adaptivity needs constant order in time and hence restol in the step parameters has to be </span><span class="se">\</span>
<span class="s1">smaller than 0!&#39;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">controller</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">mssdc_jac</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;Adaptivity needs the same order on all steps, please activate Gauss-Seidel multistep mode!&#39;</span>

        <span class="k">if</span> <span class="s1">&#39;e_tol&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="kc">False</span><span class="p">,</span>
                <span class="s1">&#39;Adaptivity needs a local tolerance! Please set some up in description[</span><span class="se">\&#39;</span><span class="s1">convergence_control</span><span class="se">\</span>
<span class="s1">_params</span><span class="se">\&#39;</span><span class="s1">][</span><span class="se">\&#39;</span><span class="s1">e_tol</span><span class="se">\&#39;</span><span class="s1">]!&#39;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;&#39;</span></div>

<div class="viewcode-block" id="Adaptivity.get_new_step_size"><a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.html#implementations.convergence_controller_classes.adaptivity.Adaptivity.get_new_step_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_new_step_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine a step size for the next step from an embedded estimate of the local error of the current step.</span>

<span class="sd">        Args:</span>
<span class="sd">            controller (pySDC.Controller): The controller</span>
<span class="sd">            S (pySDC.Step): The current step</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check if we performed the desired amount of sweeps</span>
        <span class="k">if</span> <span class="n">S</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">iter</span> <span class="o">==</span> <span class="n">S</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">maxiter</span><span class="p">:</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># compute next step size</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">iter</span>  <span class="c1"># embedded error estimate is same order as time marching</span>

            <span class="n">e_est</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_local_error_estimate</span><span class="p">(</span><span class="n">controller</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
            <span class="n">L</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">dt_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_optimal_step_size</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">beta</span><span class="p">,</span> <span class="n">L</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">e_tol</span><span class="p">,</span> <span class="n">e_est</span><span class="p">,</span> <span class="n">order</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Adjusting step size from </span><span class="si">{</span><span class="n">L</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">dt</span><span class="si">:</span><span class="s1">.2e</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">L</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">dt_new</span><span class="si">:</span><span class="s1">.2e</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Adaptivity.get_local_error_estimate"><a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.html#implementations.convergence_controller_classes.adaptivity.Adaptivity.get_local_error_estimate">[docs]</a>    <span class="k">def</span> <span class="nf">get_local_error_estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the embedded error estimate of the finest level of the step.</span>

<span class="sd">        Args:</span>
<span class="sd">            controller (pySDC.Controller): The controller</span>
<span class="sd">            S (pySDC.Step): The current step</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: Embedded error estimate</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">error_embedded_estimate</span></div></div>


<div class="viewcode-block" id="AdaptivityRK"><a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.html#implementations.convergence_controller_classes.adaptivity.AdaptivityRK">[docs]</a><span class="k">class</span> <span class="nc">AdaptivityRK</span><span class="p">(</span><span class="n">Adaptivity</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Adaptivity for Runge-Kutta methods. Basically, we need to change the order in the step size update</span>
<span class="sd">    &#39;&#39;&#39;</span>

<div class="viewcode-block" id="AdaptivityRK.check_parameters"><a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.html#implementations.convergence_controller_classes.adaptivity.AdaptivityRK.check_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">check_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">description</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Check whether parameters are compatible with whatever assumptions went into the step size functions etc.</span>
<span class="sd">        For adaptivity, we need to know the order of the scheme.</span>

<span class="sd">        Args:</span>
<span class="sd">            controller (pySDC.Controller): The controller</span>
<span class="sd">            params (dict): The params passed for this specific convergence controller</span>
<span class="sd">            description (dict): The description object used to instantiate the controller</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: Whether the parameters are compatible</span>
<span class="sd">            str: The error message</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="s1">&#39;update_order&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="kc">False</span><span class="p">,</span>
                <span class="s1">&#39;Adaptivity needs an order for the update rule! Please set some up in </span><span class="se">\</span>
<span class="s1">description[</span><span class="se">\&#39;</span><span class="s1">convergence_control_params</span><span class="se">\&#39;</span><span class="s1">][</span><span class="se">\&#39;</span><span class="s1">update_order</span><span class="se">\&#39;</span><span class="s1">]!&#39;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">AdaptivityRK</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">check_parameters</span><span class="p">(</span><span class="n">controller</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">description</span><span class="p">)</span></div>

<div class="viewcode-block" id="AdaptivityRK.get_new_step_size"><a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.html#implementations.convergence_controller_classes.adaptivity.AdaptivityRK.get_new_step_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_new_step_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Determine a step size for the next step from an embedded estimate of the local error of the current step.</span>

<span class="sd">        Args:</span>
<span class="sd">            controller (pySDC.Controller): The controller</span>
<span class="sd">            S (pySDC.Step): The current step</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># check if we performed the desired amount of sweeps</span>
        <span class="k">if</span> <span class="n">S</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">iter</span> <span class="o">==</span> <span class="n">S</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">maxiter</span><span class="p">:</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># compute next step size</span>
            <span class="n">order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">update_order</span>
            <span class="n">e_est</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_local_error_estimate</span><span class="p">(</span><span class="n">controller</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
            <span class="n">L</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">dt_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_optimal_step_size</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">beta</span><span class="p">,</span> <span class="n">L</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">e_tol</span><span class="p">,</span> <span class="n">e_est</span><span class="p">,</span> <span class="n">order</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Adjusting step size from </span><span class="si">{</span><span class="n">L</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">dt</span><span class="si">:</span><span class="s1">.2e</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">L</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">dt_new</span><span class="si">:</span><span class="s1">.2e</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span></div></div>


<div class="viewcode-block" id="AdaptivityResidual"><a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.html#implementations.convergence_controller_classes.adaptivity.AdaptivityResidual">[docs]</a><span class="k">class</span> <span class="nc">AdaptivityResidual</span><span class="p">(</span><span class="n">AdaptivityBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Do adaptivity based on residual.</span>

<span class="sd">    Since we don&#39;t know a correlation between the residual and the error (for nonlinear problems), we employ a simpler</span>
<span class="sd">    rule to update the step size. Instead of giving a local tolerance that we try to hit as closely as possible, we set</span>
<span class="sd">    two thresholds for the residual. When we exceed the upper one, we reduce the step size by a factor of 2 and if the</span>
<span class="sd">    residual falls below the lower threshold, we double the step size.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="AdaptivityResidual.setup"><a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.html#implementations.convergence_controller_classes.adaptivity.AdaptivityResidual.setup">[docs]</a>    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">description</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define default parameters here.</span>

<span class="sd">        Default parameters are:</span>
<span class="sd">         - control_order (int): The order relative to other convergence controllers</span>
<span class="sd">         - e_tol_low (float): Lower absolute threshold for the residual</span>
<span class="sd">         - e_tol (float): Upper absolute threshold for the residual</span>
<span class="sd">         - max_restarts: Override maximum number of restarts</span>

<span class="sd">        Args:</span>
<span class="sd">            controller (pySDC.Controller): The controller</span>
<span class="sd">            params (dict): The params passed for this specific convergence controller</span>
<span class="sd">            description (dict): The description object used to instantiate the controller</span>

<span class="sd">        Returns:</span>
<span class="sd">            (dict): The updated params dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;control_order&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">45</span><span class="p">,</span>
            <span class="s1">&#39;e_tol_low&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s1">&#39;e_tol&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
            <span class="s1">&#39;max_restarts&#39;</span><span class="p">:</span> <span class="mi">2</span> <span class="k">if</span> <span class="s1">&#39;e_tol_low&#39;</span> <span class="ow">in</span> <span class="n">params</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="p">{</span><span class="o">**</span><span class="n">defaults</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">}</span></div>

<div class="viewcode-block" id="AdaptivityResidual.setup_status_variables"><a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.html#implementations.convergence_controller_classes.adaptivity.AdaptivityResidual.setup_status_variables">[docs]</a>    <span class="k">def</span> <span class="nf">setup_status_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">controller</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change maximum number of allowed restarts here.</span>

<span class="sd">        Args:</span>
<span class="sd">            controller (pySDC.Controller): The controller</span>

<span class="sd">        Reutrns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">max_restarts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">conv_controllers</span> <span class="o">=</span> <span class="n">controller</span><span class="o">.</span><span class="n">convergence_controllers</span>
            <span class="n">restart_cont</span> <span class="o">=</span> <span class="p">[</span><span class="n">me</span> <span class="k">for</span> <span class="n">me</span> <span class="ow">in</span> <span class="n">conv_controllers</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">me</span><span class="p">)</span> <span class="o">==</span> <span class="n">BasicRestartingNonMPI</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">restart_cont</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Please implement override of maximum number of restarts!&quot;</span><span class="p">)</span>

            <span class="n">restart_cont</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">max_restarts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">max_restarts</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="AdaptivityResidual.check_parameters"><a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.html#implementations.convergence_controller_classes.adaptivity.AdaptivityResidual.check_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">check_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">description</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether parameters are compatible with whatever assumptions went into the step size functions etc.</span>
<span class="sd">        For adaptivity, we want a fixed order of the scheme.</span>

<span class="sd">        Args:</span>
<span class="sd">            controller (pySDC.Controller): The controller</span>
<span class="sd">            params (dict): The params passed for this specific convergence controller</span>
<span class="sd">            description (dict): The description object used to instantiate the controller</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: Whether the parameters are compatible</span>
<span class="sd">            str: The error message</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">description</span><span class="p">[</span><span class="s1">&#39;step_params&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;restol&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="kc">False</span><span class="p">,</span>
                <span class="s1">&#39;Adaptivity needs constant order in time and hence restol in the step parameters has to be </span><span class="se">\</span>
<span class="s1">smaller than 0!&#39;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">controller</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">mssdc_jac</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;Adaptivity needs the same order on all steps, please activate Gauss-Seidel multistep mode!&#39;</span>

        <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;&#39;</span></div>

<div class="viewcode-block" id="AdaptivityResidual.get_new_step_size"><a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.html#implementations.convergence_controller_classes.adaptivity.AdaptivityResidual.get_new_step_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_new_step_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine a step size for the next step.</span>
<span class="sd">        If we exceed the absolute tolerance of the residual in either direction, we either double or halve the step</span>
<span class="sd">        size.</span>

<span class="sd">        Args:</span>
<span class="sd">            controller (pySDC.Controller): The controller</span>
<span class="sd">            S (pySDC.Step): The current step</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check if we performed the desired amount of sweeps</span>
        <span class="k">if</span> <span class="n">S</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">iter</span> <span class="o">==</span> <span class="n">S</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">maxiter</span><span class="p">:</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_local_error_estimate</span><span class="p">(</span><span class="n">controller</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>

            <span class="n">dt_planned</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">dt_new</span> <span class="k">if</span> <span class="n">L</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">dt_new</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">L</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">dt</span>

            <span class="k">if</span> <span class="n">res</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">e_tol</span><span class="p">:</span>
                <span class="n">L</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">dt_new</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">dt_planned</span><span class="p">,</span> <span class="n">L</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">dt</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Adjusting step size from </span><span class="si">{</span><span class="n">L</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">dt</span><span class="si">:</span><span class="s1">.2e</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">L</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">dt_new</span><span class="si">:</span><span class="s1">.2e</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">res</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">e_tol_low</span><span class="p">:</span>
                <span class="n">L</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">dt_new</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">dt_planned</span><span class="p">,</span> <span class="n">L</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">dt</span> <span class="o">*</span> <span class="mf">2.0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Adjusting step size from </span><span class="si">{</span><span class="n">L</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">dt</span><span class="si">:</span><span class="s1">.2e</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">L</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">dt_new</span><span class="si">:</span><span class="s1">.2e</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="AdaptivityResidual.get_local_error_estimate"><a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.html#implementations.convergence_controller_classes.adaptivity.AdaptivityResidual.get_local_error_estimate">[docs]</a>    <span class="k">def</span> <span class="nf">get_local_error_estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the residual of the finest level of the step.</span>

<span class="sd">        Args:</span>
<span class="sd">            controller (pySDC.Controller): The controller</span>
<span class="sd">            S (pySDC.Step): The current step</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: Embedded error estimate</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">residual</span></div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">pySDC 5.0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">implementations.convergence_controller_classes.adaptivity</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2022, Robert Speck.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.2.3.
    </div>
  </body>
</html>